#!/bin/env -S node --experimental-vm-modules --inspect-brk

const fs = require("fs");
const vm = require("vm");
const path = require("path");
const ByteCodeLinker = require("../src/bclinker.js");
const ARLinker = require("../src/ar-loader.js");
const DylibSymbolLinker = require("../src/dylib-loader.js");

// 
// TODO (Next-up):
// - Try to merge the data-segments to build the "export" memory locations
// - fixup builtin(s)
// - fixup objc

function supportsFile(arg) {
    return arg.endsWith(".bc") || arg.endsWith(".so.wasm") || arg.endsWith(".a");
}

function loadYLinkerScripts() {

    // load default wasm impl enviroment
    let script = fs.readFileSync(path.join(__dirname, "../dist/wasm-info.js"), {encoding: 'utf8'});
    let wasmInfoScript = new vm.Script(script, {filename: "wasm-info.js"});
    wasmInfoScript.runInThisContext();

    script = fs.readFileSync(path.join(__dirname, "../dist/inst-info.js"), {encoding: 'utf8'});
    let instInfoScript = new vm.Script(script, {filename: "inst-info.js"});
    instInfoScript.runInThisContext();

    script = fs.readFileSync(path.join(__dirname, "../dist/wat-parse.js"), {encoding: 'utf8'});
    let watScript = new vm.Script(script, {filename: "wat-parse.js"});
    watScript.runInThisContext();

    script = fs.readFileSync(path.join(__dirname, "../src/wasm-custom.js"), {encoding: 'utf8'});
    let bclinkerScript = new vm.Script(script, {filename: "./src/wasm-custom.js"});
    bclinkerScript.runInThisContext();

    //script = fs.readFileSync(path.join(__dirname, "../src/bclinker.js"), {encoding: 'utf8'});
    //let bclinkerScript = new vm.Script(script, {filename: "./src/bclinker.js"});
    //bclinkerScript.runInThisContext();

    script = fs.readFileSync(path.join(__dirname, "../src/fixup-builtin.js"), {encoding: 'utf8'});
    let fixupScript = new vm.Script(script, {filename: "fixup-builtin.js"});
    fixupScript.runInThisContext();

    script = fs.readFileSync(path.join(__dirname, "../src/fixup-objc.js"), {encoding: 'utf8'});
    fixupScript = new vm.Script(script, {filename: "fixup-objc.js"});
    fixupScript.runInThisContext();
}

const opt_template = {
    '--synthesize-objc_msgSend': 1, // JUST a boolean flags, if present its true.
};

const LNK_DATA_SUFFIX = ".ylinker-data"

function main() {
    console.log(process.argv);
    console.log(process.cwd());
    //console.log(process.env);
    
    let bopts = [];
    let moduleName;
    let outfile, rspfile;
    let files = [];
    let flags = {};
    let exported = [];
    let opts = {};

    let argv = process.argv;
    let argc = argv.length;
    for (let i = 0; i < argc; i++) {
        let arg = argv[i];
        if (arg.startsWith("@") && arg.endsWith(".rsp")) {
            rspfile = arg.substring(1);
        } else if (arg == '-o') {
            outfile = argv[i + 1];
            i++;
        }
    }

    if (rspfile) {
        let data = fs.readFileSync(rspfile, {encoding: 'utf8'});
        let len = data.length;
        let idx = 0;
        let args = [];
        while (idx < len) {
            let quoted = false;
            let nxt, chr, str = "";
            // skip one or more space.
            while (idx < len) {
                chr = data.charCodeAt(idx);
                if (chr != 0x09 && chr != 0x20) {
                    break;
                }
                idx++;
            }

            if (chr == 0x27) {
                // single quoted string
                idx++;
                quoted = true;
                while (idx < len) {
                    chr = data.charCodeAt(idx);
                    if (chr == 0x5c) {
                        idx++;
                        nxt = data.charCodeAt(idx);
                        if (nxt == 0x27) {
                            str += '\'';
                        } else if (nxt == 0x22) {
                            str += '\"';
                        } else if (nxt == 0x74) {
                            str += '\t';
                        } else {
                            console.log("found '%s' char-code: %s", data[idx], nxt.toString(16));
                        }
                    } else if (chr == 0x27) {
                        idx++;
                        break;
                    } else {
                        str += data[idx];
                    }
                    idx++;
                }
            } else if (chr == 0x22) {
                // double quoted string
                idx++;
                quoted = true;
                while (idx < len) {
                    chr = data.charCodeAt(idx);
                    if (chr == 0x5c) {
                        idx++;
                        nxt = data.charCodeAt(idx);
                        if (nxt == 0x27) {
                            str += '\'';
                        } else if (nxt == 0x22) {
                            str += '\"';
                        } else if (nxt == 0x74) {
                            str += '\t';
                        } else {
                            console.log("found '%s' char-code: %s", data[idx], nxt.toString(16));
                        }
                    } else if (chr == 0x22) {
                        idx++;
                        break;
                    } else {
                        str += data[idx];
                    }
                    idx++;
                }
            } else {
                // unquoted argument
                quoted = false;
                while (idx < len) {
                    chr = data.charCodeAt(idx);
                    if (chr == 0x5c) {
                        idx++;
                        nxt = data.charCodeAt(idx);
                        if (nxt == 0x20) {
                            str += '\x20';
                        } else if (nxt == 0x09) {
                            str += '\x09';
                        } else {
                            console.log("found '%s' char-code: %s", data[idx], nxt.toString(16));
                        }
                    } else if (chr == 0x20) {
                        break;
                    } else {
                        str += data[idx];
                    }
                    idx++;
                }
            }

            if (str.length > 0) {
                let arg = str;
                args.push(str);
                if (quoted == false) {
                    if (arg.startsWith("--export=")) {
                        let name = arg.substring(9);
                        if (exported.indexOf(name) == -1)
                            exported.push(name);
                    } else if (arg.startsWith("--module-name=")) {
                        moduleName = arg.substring(14);
                        if (moduleName.startsWith("\"") && moduleName.endsWith("\"")) {
                            moduleName = moduleName.substring(1, moduleName.length - 1);
                        }
                    } else if (arg.startsWith("--dylink-profiles-dirpath=")) {
                        opts.dylink_profiles_dirpath = arg.substring(26);
                    } else if (arg.startsWith("-L")) {
                        // library search path
                        console.log("library search path '-L' not implemented");
                    } else if (arg.startsWith("-l")) {
                        // linked library
                        console.log("linked library '-l' not implemented");
                    } else if (arg.startsWith("--")) {
                        // flag
                        flags[arg] = arg;
                    } else if (arg.startsWith("-")) {
                        // flag
                        flags[arg] = arg;
                    }  else if (supportsFile(arg)) {
                        files.push(arg);
                    } else {
                        console.log(arg);
                        throw new Error("unexpected unquoted argument");
                    }

                } else if (supportsFile(arg)) {
                    files.push(arg);
                }
            }
            str = "";
        }

        //console.log(args);
    }

    loadYLinkerScripts();

    let parseOptions = {linking: true};

    let emptymap = new Map();
    let len = files.length;
    let bclinker = new ByteCodeLinker();
    bclinker.options = opts;
    //len = Math.min(4, len);
    let signbuf = new Uint8Array(8);
    let data = new DataView(signbuf.buffer);

    if (opts.so_ident) {
        bclinker.so_ident = opts.so_ident;
    } else {
        bclinker.so_ident = generateSOIdent(outfile);
    }

    if (moduleName) {
        bclinker.moduleName = moduleName;
    }
    
    // pre-group files based on file extentions (works in some cases..)
    for (let i = 0; i < len; i++) {
        let mod, file = files[i];
        console.log("linking file: %s", file);

        if (file.endsWith(".so.wasm") || file.endsWith(".dylib.wasm")) {
            console.log("should read %s as dynamic / shared object", file);
            let dlnk_file;
            try {
                dlnk_file = findDylinkedFile(null, file);
            } catch {
                console.error("missing %s linker file for %s", file);
                continue;
            }

            let infd = fs.openSync(dlnk_file, 'r');
            let filesize = fs.fstatSync(infd).size;
            let linker = DylibSymbolLinker.fromSymbolFile(infd, filesize);
            linker.filepath = file;
            bclinker.linkTo(linker, 'dylink');
            continue;
        }

        let infd;
        try {
            infd = fs.openSync(file, 'r');
        } catch (err) {
            console.error(err);
        }

        let filesize = fs.fstatSync(infd).size;
        fs.readSync(infd, signbuf, 0, 8, 0);

        if (data.getUint32(0, true) == 0x6d736100) {
            // reading and parsing wasm binary
            let buf = new Uint8Array(filesize);
            fs.readSync(infd, buf, 0, filesize, 0);
            mod = parseWebAssemblyBinary(buf, parseOptions);

            bclinker.prepareLinking(mod);
            bclinker.mergeWithModule(mod);
            fs.closeSync(infd);

        } else if (data.getUint32(0, true) == 0x72613C21 && data.getUint32(4, true) == 0x0A3E6863) { // == !<arch>\n
            log_code_relocs(bclinker);
            //let infd = fs.openSync(file);
            let linker = ARLinker.fromArchive(infd, filesize, parseOptions);
            linker.filepath = file;
            bclinker.linkTo(linker, 'static');
        }
    }

    bclinker.is_main_exec = outfile.endsWith(".so.wasm") == false;

    bclinker.performLinking();

    /*
    let logout = outfile + ".symbol-log";
    try {
        outfd = fs.openSync(logout, 'w+', 438); // truncated if exists mode: 0666
        bclinker.writeSymbolLog(outfd);
        fs.closeSync(outfd);
    } catch (err) {
        console.error("cannot read/write %s", logout);
        console.error(err);
        fs.closeSync(outfd);
        //throw err;
    }*/


    outfd = -1;
    let outfiletmp = outfile + ".tmp";
    try {
        outfd = fs.openSync(outfiletmp, 'w+', 438); // truncated if exists mode: 0666
        //throw new Error("DO NOT WRITE UNTIL WE ARE TESTING BINARY");
        bclinker.writeModule(outfd);
        fs.closeSync(outfd);
        outfd = -1;
        fs.renameSync(outfiletmp, outfile);
    } catch (err) {
        console.error("cannot read/write %s", outfiletmp);
        if (outfd !== -1)
            fs.closeSync(outfd);
        throw err
    }

}

function generateSOIdent(filepath) {
    let parts = filepath.split('/');
    parts = parts.pop();
    if (parts.endsWith(".dylib.wasm")) {
        let end = parts.lastIndexOf(".dylib.wasm");
        parts = parts.substring(0, end);
    } else if (parts.endsWith(".so.wasm")) {
        let end = parts.lastIndexOf(".so.wasm");
        parts = parts.substring(0, end);
    } else if (parts.endsWith(".wasm")) {
        let end = parts.lastIndexOf(".wasm");
        parts = parts.substring(0, end);
    }

    return parts.replace(/[\s\.]/gm, '_');
}

function findDylinkedFile(paths, filename) {
    let found = false;
    let names = [filename];
    let testname = filename;
    if (filename.endsWith(".so.wasm")) {
        let name = filename.substring(0, filename.length - 8);
        names.push(name + ".wasm");
        names.push(name + ".dylib");
        names.push(name + ".so");
    } else if (filename.endsWith(".wasm")) {
        let name = filename.substring(0, filename.length - 5);
        names.push(name + ".wasm");
        names.push(name + ".dylib");
        names.push(name + ".so");
    }

    let len = names.length;
    for (let i = 0; i < len; i++) {
        let name = names[i];
        try {
            fs.accessSync(name, fs.constants.R_OK);
            return name;
        } catch (err) {
            // do nothing
        }
    }

    throw new ReferenceError("LINKER_FILE_NOT_FOUND");
}

function findLinkerDataFile(filename) {
    let found = false;
    let lnkfile = filename + LNK_DATA_SUFFIX;
    try {
        fs.accessSync(lnkfile, fs.constants.R_OK);
        return lnkfile;
    } catch (err) {
        // do nothing
    }

    let parts = filename.split('.');
    parts.pop();
    lnkfile = parts.join('.') + LNK_DATA_SUFFIX;
    try {
        fs.accessSync(lnkfile, fs.constants.R_OK);
        return lnkfile;
    } catch (err) {
        // do nothing
    }

    throw new ReferenceError("LINKER_FILE_NOT_FOUND");
}

function log_code_relocs(bclinker) {
    let code_relocs = bclinker._code_relocs;
    let types = [];
    let len = code_relocs.length;
    for (let i = 0; i < len; i++) {
        let reloc = code_relocs[i];
        if (types.indexOf(reloc.type) == -1) {
            types.push(reloc.type);
        }
    }

    console.log('reloc types %o', types);
}

// args & rsp example for executable:
// [
//   '/home/raweden/.nvm/versions/node/v16.15.1/bin/node',
//   '/home/raweden/Projects/wasm-info/bin/wasm-ylinker',
//   '-o',
//   'gdnc.wasm',
//   '@gdnc.wasm.rsp'
// ]
// [
//   '--export-all',
//   '--no-entry',
//   '-error-limit=1000',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Tools/gdnc.bc',
//   'obj/ABS_PATH/home/raweden/Projects/netbsd-src/lib/libc/arch/wasm/libnetbsd-libc.a',
//   'libs-base.so.wasm'
// ]
// 
// args & rsp example for shared-library
// [1/3] SOLINK libs-base.so.wasm
// [
//   '/home/raweden/.nvm/versions/node/v16.15.1/bin/node',
//   '/home/raweden/Projects/wasm-info/bin/wasm-ylinker',
//   '-o',
//   'libs-base.so.wasm',
//   '@libs-base.so.wasm.rsp'
// ]
// [
//   '-L/home/raweden/Projects/GnuStep on WebAssembly/libobjc2/objc',
//   '-L../../include',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Source/wasm/objcgnustep.bc',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Source/callframe.bc',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Source/externs.bc',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Source/GSArray.bc',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Source/GSAttributedString.bc',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Source/GSBlocks.bc',
//   'obj/ABS_PATH/home/raweden/Projects/GnuStep on WebAssembly/libs-base/Source/GSConcreteValue.bc',
// ]

main();





function prepareLinking(wasmModule) {

}

